<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Duplicates</title>
<style>
	pre {
		background-color: #FFD;
		border: 1px solid #E2E2E2;
		padding: 1ex;
	}
</style>
<h1>#1 found 3 clones</h1>
<h2>internal\movegen\perft_test.go:137</h2>
<pre>for depth := 1; depth <= maxDepth; depth++ {
	perft.StartPerft("r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - ", depth, true)
	assert.Equal(kiwipete[depth][1], perft.Nodes)
	assert.Equal(kiwipete[depth][2], perft.CaptureCounter)
	assert.Equal(kiwipete[depth][3], perft.EnpassantCounter)
	assert.Equal(kiwipete[depth][4], perft.CheckCounter)
	assert.Equal(kiwipete[depth][5], perft.CheckMateCounter)
	assert.Equal(kiwipete[depth][6], perft.CastleCounter)
	assert.Equal(kiwipete[depth][7], perft.PromotionCounter)
}</pre>
<h2>internal\movegen\perft_test.go:169</h2>
<pre>for depth := 1; depth <= maxDepth; depth++ {
	perft.StartPerft("r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq -", depth, false)
	assert.Equal(mirrorPerft[depth][1], perft.Nodes)
	assert.Equal(mirrorPerft[depth][2], perft.CaptureCounter)
	assert.Equal(mirrorPerft[depth][3], perft.EnpassantCounter)
	assert.Equal(mirrorPerft[depth][4], perft.CheckCounter)
	assert.Equal(mirrorPerft[depth][5], perft.CheckMateCounter)
	assert.Equal(mirrorPerft[depth][6], perft.CastleCounter)
	assert.Equal(mirrorPerft[depth][7], perft.PromotionCounter)
}</pre>
<h2>internal\movegen\perft_test.go:181</h2>
<pre>for depth := 1; depth <= maxDepth; depth++ {
	perft.StartPerft("r2q1rk1/pP1p2pp/Q4n2/bbp1p3/Np6/1B3NBn/pPPP1PPP/R3K2R b KQ -", depth, false)
	assert.Equal(mirrorPerft[depth][1], perft.Nodes)
	assert.Equal(mirrorPerft[depth][2], perft.CaptureCounter)
	assert.Equal(mirrorPerft[depth][3], perft.EnpassantCounter)
	assert.Equal(mirrorPerft[depth][4], perft.CheckCounter)
	assert.Equal(mirrorPerft[depth][5], perft.CheckMateCounter)
	assert.Equal(mirrorPerft[depth][6], perft.CastleCounter)
	assert.Equal(mirrorPerft[depth][7], perft.PromotionCounter)
}</pre>
<h1>#2 found 2 clones</h1>
<h2>internal\types\bitboard.go:1042</h2>
<pre>for j := 0; j < (1 << dl); j++ {
	var mask, mask2 Bitboard
	// Calculate possible target squares
	for x := int(file) - int(dsfile) - 1; x >= 0; x-- {
		mask += BbOne << x
		if (j & (1 << x)) != 0 {
			break
		}
	}
	for x := int(file) - int(dsfile) + 1; x < dl; x++ {
		mask += BbOne << x
		if (j & (1 << x)) != 0 {
			break
		}
	}
	/* Rotate the target line back onto the required diagonal */
	for x := 0; x < dl; x++ {
		mask2 += ((mask >> x) & 1) << (int(diagstart) - (7 * x))
	}
	movesDiagDown[square][j] = mask2
}</pre>
<h2>internal\types\bitboard.go:1078</h2>
<pre>for sq := 0; sq < (1 << dl); sq++ {
	var mask, mask2 Bitboard
	/* Calculate possible target squares */
	for b1 := int(file) - int(dsfile) - 1; b1 >= 0; b1-- {
		mask += BbOne << b1
		if (sq & (1 << b1)) != 0 {
			break
		}
	}
	for b2 := int(file) - int(dsfile) + 1; b2 < dl; b2++ {
		mask += BbOne << b2
		if (sq & (1 << b2)) != 0 {
			break
		}
	}
	/* Rotate target squares back */
	for x := 0; x < dl; x++ {
		mask2 += ((mask >> x) & 1) << (int(diagstart) + (9 * x))
	}
	movesDiagUp[square][sq] = mask2
}</pre>
<h1>#3 found 2 clones</h1>
<h2>internal\movegen\perft_test.go:42</h2>
<pre>func TestStandardPerft(t *testing.T) {

	maxDepth := 5
	var perft Perft
	assert := assert.New(t)

	var results = [10][6]uint64{
		// @formatter:off
		// N             Nodes         Captures           EP          Checks           Mates
		{ 0,                 1,               0,           0,              0,              0 },
		{ 1,                20,               0,           0,              0,              0 },
		{ 2,               400,               0,           0,              0,              0 },
		{ 3,             8_902,              34,           0,             12,              0 },
		{ 4,           197_281,           1_576,           0,            469,              8 },
		{ 5,         4_865_609,          82_719,         258,         27_351,            347 },
		{ 6,       119_060_324,       2_812_008,       5_248,        809_099,         10_828 },
		{ 7,     3_195_901_860,     108_329_926,     319_617,     33_103_848,        435_767 },
		{ 8,    84_998_978_956,   3_523_740_106,   7_187_977,    968_981_593,      9_852_036 },
		{ 9, 2_439_530_234_167, 125_208_536_153, 319_496_827, 36_095_901_903,    400_191_963 }}
	// @formatter:on

	for i := 1; i <= maxDepth; i++ {
		perft.StartPerft(position.StartFen, i, false)
		assert.Equal(results[i][1], perft.Nodes)
		assert.Equal(results[i][2], perft.CaptureCounter)
		assert.Equal(results[i][3], perft.EnpassantCounter)
		assert.Equal(results[i][4], perft.CheckCounter)
		assert.Equal(results[i][5], perft.CheckMateCounter)
	}
}</pre>
<h2>internal\movegen\perft_test.go:88</h2>
<pre>func TestStandardPerftOd(t *testing.T) {

	maxDepth := 5
	var perft Perft
	assert := assert.New(t)

	var results = [10][6]uint64{
		// @formatter:off
		// N             Nodes         Captures           EP          Checks           Mates
		{ 0,                 1,               0,           0,              0,              0 },
		{ 1,                20,               0,           0,              0,              0 },
		{ 2,               400,               0,           0,              0,              0 },
		{ 3,             8_902,              34,           0,             12,              0 },
		{ 4,           197_281,           1_576,           0,            469,              8 },
		{ 5,         4_865_609,          82_719,         258,         27_351,            347 },
		{ 6,       119_060_324,       2_812_008,       5_248,        809_099,         10_828 },
		{ 7,     3_195_901_860,     108_329_926,     319_617,     33_103_848,        435_767 },
		{ 8,    84_998_978_956,   3_523_740_106,   7_187_977,    968_981_593,      9_852_036 },
		{ 9, 2_439_530_234_167, 125_208_536_153, 319_496_827, 36_095_901_903,    400_191_963 }}
	// @formatter:on

	for i := 1; i <= maxDepth; i++ {
		perft.StartPerft(position.StartFen, i, true)
		assert.Equal(results[i][1], perft.Nodes)
		assert.Equal(results[i][2], perft.CaptureCounter)
		assert.Equal(results[i][3], perft.EnpassantCounter)
		assert.Equal(results[i][4], perft.CheckCounter)
		assert.Equal(results[i][5], perft.CheckMateCounter)
	}
}</pre>
<h1>#4 found 2 clones</h1>
<h2>internal\movegen\movegen_test.go:571</h2>
<pre>func TestTimingGenerateMovesOld(t *testing.T) {
	// defer profile.Start(profile.CPUProfile, profile.ProfilePath(".")).Stop()
	// go tool pprof -http :8080 ./main ./prof.null/cpu.pprof

	if testing.Short() {
		t.Skip("skipping test in short mode.")
	}

	mg := NewMoveGen()
	p := position.NewPosition("r1b1k2r/pppp1ppp/2n2n2/1Bb1p2q/4P3/2NP1N2/1PP2PPP/R1BQK2R w KQkq -")
	result := Value(0)

	const rounds = 5
	const iterations uint64 = 10_000_000

	for r := 1; r <= rounds; r++ {
		out.Printf("Round %d\n", r)
		start := time.Now()
		for i := uint64(0); i < iterations; i++ {
			mg.pseudoLegalMoves.Clear()
			mg.generateMovesOld(p, GenAll, mg.pseudoLegalMoves)
		}
		elapsed := time.Since(start)
		out.Printf("Test took %s for %d iterations\n", elapsed, iterations)
		out.Printf("Test took %d ns per iteration\n", elapsed.Nanoseconds()/int64(iterations))
		out.Printf("Iterations per sec %d\n", int64(iterations*1e9)/elapsed.Nanoseconds())
	}
	_ = result
}</pre>
<h2>internal\movegen\movegen_test.go:601</h2>
<pre>func TestTimingGenerateMovesNew(t *testing.T) {
	// defer profile.Start(profile.CPUProfile, profile.ProfilePath(".")).Stop()
	// go tool pprof -http :8080 ./main ./prof.null/cpu.pprof

	if testing.Short() {
		t.Skip("skipping test in short mode.")
	}

	mg := NewMoveGen()
	p := position.NewPosition("r1b1k2r/pppp1ppp/2n2n2/1Bb1p2q/4P3/2NP1N2/1PP2PPP/R1BQK2R w KQkq -")
	result := Value(0)

	const rounds = 5
	const iterations uint64 = 10_000_000

	for r := 1; r <= rounds; r++ {
		out.Printf("Round %d\n", r)
		start := time.Now()
		for i := uint64(0); i < iterations; i++ {
			mg.pseudoLegalMoves.Clear()
			mg.generateMoves(p, GenAll, mg.pseudoLegalMoves)
		}
		elapsed := time.Since(start)
		out.Printf("Test took %s for %d iterations\n", elapsed, iterations)
		out.Printf("Test took %d ns per iteration\n", elapsed.Nanoseconds()/int64(iterations))
		out.Printf("Iterations per sec %d\n", int64(iterations*1e9)/elapsed.Nanoseconds())
	}
	_ = result
}</pre>
<h1>#5 found 2 clones</h1>
<h2>internal\types\file_test.go:27</h2>
<pre>package types

import "testing"

func TestFileType(t *testing.T) {
	tests := []struct {
		value    File
		expected int
	}{
		{FileA, 0},
		{FileH, 7},
		{FileNone, 8},
		{File(100), 100},
	}
	var got int
	for _, test := range tests {
		got = int(test.value)
		if test.expected != got {
			t.Errorf("file %s == %d expected. Got %d", test.value.String(), test.expected, got)
		} else {
			t.Logf("file %s == %d", test.value.String(), got)
		}
	}
}

func TestValidFile(t *testing.T) {
	tests := []struct {
		value    File
		expected bool
	}{
		{FileA, true},
		{FileH, true},
		{FileNone, false},
		{File(100), false},
	}
	var got bool
	for _, test := range tests {
		got = test.value.IsValid()
		if test.expected != got {
			t.Errorf("file.valid(%s) %t expected. Got %t", test.value.String(), test.expected, got)
		} else {
			t.Logf("file.valid(%s) == %t", test.value.String(), got)
		}
	}
}

func TestFileStr(t *testing.T) {
	tests := []struct {
		value    File
		expected string
	}{
		{FileA, "a"},
		{FileH, "h"},
		{FileNone, "-"},
		{File(100), "-"},
	}
	var got string
	for _, test := range tests {
		got = test.value.String()
		if test.expected != got {
			t.Errorf("file label %s is expected. Got %s", test.expected, got)
		} else {
			t.Logf("file label %s is %s", test.value.String(), got)
		}
	}
}</pre>
<h2>internal\types\rank_test.go:27</h2>
<pre>package types

import "testing"

func TestRankType(t *testing.T) {
	tests := []struct {
		value    Rank
		expected int
	}{
		{Rank1, 0},
		{Rank8, 7},
		{RankNone, 8},
		{Rank(100), 100},
	}
	var got int
	for _, test := range tests {
		got = int(test.value)
		if test.expected != got {
			t.Errorf("rank %s == %d expected. Got %d", test.value.String(), test.expected, got)
		} else {
			t.Logf("rank %s == %d", test.value.String(), got)
		}
	}
}

func TestValidRank(t *testing.T) {
	tests := []struct {
		value    Rank
		expected bool
	}{
		{Rank1, true},
		{Rank8, true},
		{RankNone, false},
		{Rank(100), false},
	}
	var got bool
	for _, test := range tests {
		got = test.value.IsValid()
		if test.expected != got {
			t.Errorf("rank.valid(%s) %t expected. Got %t", test.value.String(), test.expected, got)
		} else {
			t.Logf("rank.valid(%s) == %t", test.value.String(), got)
		}
	}
}

func TestRankStr(t *testing.T) {
	tests := []struct {
		value    Rank
		expected string
	}{
		{Rank1, "1"},
		{Rank8, "8"},
		{RankNone, "-"},
		{Rank(100), "-"},
	}
	var got string
	for _, test := range tests {
		got = test.value.String()
		if test.expected != got {
			t.Errorf("rank label %s is expected. Got %s", test.expected, got)
		} else {
			t.Logf("rank label %s is %s", test.value.String(), got)
		}
	}
}</pre>
<h1>#6 found 2 clones</h1>
<h2>internal\types\bitboard.go:822</h2>
<pre>if        DiagUpA8&sq.bitboard() > 0 { sqDiagUpBb[sq] = DiagUpA8
} else if DiagUpA7&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA7
} else if DiagUpA6&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA6
} else if DiagUpA5&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA5
} else if DiagUpA4&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA4
} else if DiagUpA3&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA3
} else if DiagUpA2&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA2
} else if DiagUpA1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA1
} else if DiagUpB1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpB1
} else if DiagUpC1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpC1
} else if DiagUpD1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpD1
} else if DiagUpE1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpE1
} else if DiagUpF1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpF1
} else if DiagUpG1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpG1
} else if DiagUpH1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpH1
}</pre>
<h2>internal\types\bitboard.go:823</h2>
<pre>       if DiagUpA7&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA7
} else if DiagUpA6&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA6
} else if DiagUpA5&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA5
} else if DiagUpA4&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA4
} else if DiagUpA3&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA3
} else if DiagUpA2&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA2
} else if DiagUpA1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpA1
} else if DiagUpB1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpB1
} else if DiagUpC1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpC1
} else if DiagUpD1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpD1
} else if DiagUpE1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpE1
} else if DiagUpF1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpF1
} else if DiagUpG1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpG1
} else if DiagUpH1&sq.bitboard() > 0 {	sqDiagUpBb[sq] = DiagUpH1
}</pre>
<h1>#7 found 4 clones</h1>
<h2>internal\position\position.go:716</h2>
<pre>case SqG1:
	if assert.DEBUG {
		assert.Assert(p.castlingRights.Has(CastlingWhiteOO), "Position DoMove: White king side castling not available")
		assert.Assert(fromSq == SqE1, "Position DoMove: Castling from square not correct")
		assert.Assert(p.board[SqE1] == WhiteKing, "Position DoMove: SqE1 has no king for castling")
		assert.Assert(p.board[SqH1] == WhiteRook, "Position DoMove: SqH1 has no rook for castling")
		assert.Assert(p.OccupiedAll()&Intermediate(SqE1, SqH1) == 0, "Position DoMove: Castling king side blocked")
	}
	p.movePiece(fromSq, toSq)                                    // King
	p.movePiece(SqH1, SqF1)                                      // Rook
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights] // out
	p.castlingRights.Remove(CastlingWhite)
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights]</pre>
<h2>internal\position\position.go:729</h2>
<pre>case SqC1:
	if assert.DEBUG {
		assert.Assert(p.castlingRights.Has(CastlingWhiteOOO), "Position DoMove: White queen side castling not available")
		assert.Assert(fromSq == SqE1, "Position DoMove: Castling from square not correct")
		assert.Assert(p.board[SqE1] == WhiteKing, "Position DoMove: SqE1 has no king for castling")
		assert.Assert(p.board[SqA1] == WhiteRook, "Position DoMove: SqA1 has no rook for castling")
		assert.Assert(p.OccupiedAll()&Intermediate(SqE1, SqA1) == 0, "Position DoMove: Castling queen side blocked")
	}
	p.movePiece(fromSq, toSq)                                    // King
	p.movePiece(SqA1, SqD1)                                      // Rook
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights] // out
	p.castlingRights.Remove(CastlingWhite)
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights]</pre>
<h2>internal\position\position.go:742</h2>
<pre>case SqG8:
	if assert.DEBUG {
		assert.Assert(p.castlingRights.Has(CastlingBlackOO), "Position DoMove: Black king side castling not available")
		assert.Assert(fromSq == SqE8, "Position DoMove: Castling from square not correct")
		assert.Assert(p.board[SqE8] == BlackKing, "Position DoMove: SqE8 has no king for castling")
		assert.Assert(p.board[SqH8] == BlackRook, "Position DoMove: SqH8 has no rook for castling")
		assert.Assert(p.OccupiedAll()&Intermediate(SqE8, SqH8) == 0, "Position DoMove: Castling king side blocked")
	}
	p.movePiece(fromSq, toSq)                                    // King
	p.movePiece(SqH8, SqF8)                                      // Rook
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights] // out
	p.castlingRights.Remove(CastlingBlack)
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights]</pre>
<h2>internal\position\position.go:755</h2>
<pre>case SqC8:
	if assert.DEBUG {
		assert.Assert(p.castlingRights.Has(CastlingBlackOOO), "Position DoMove: Black queen side castling not available")
		assert.Assert(fromSq == SqE8, "Position DoMove: Castling from square not correct")
		assert.Assert(p.board[SqE8] == BlackKing, "Position DoMove: SqE8 has no king for castling")
		assert.Assert(p.board[SqA8] == BlackRook, "Position DoMove: SqA8 has no rook for castling")
		assert.Assert(p.OccupiedAll()&Intermediate(SqE8, SqA8) == 0, "Position DoMove: Castling queen side blocked")
	}
	p.movePiece(fromSq, toSq)                                    // King
	p.movePiece(SqA8, SqD8)                                      // Rook
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights] // out
	p.castlingRights.Remove(CastlingBlack)
	p.zobristKey ^= zobristBase.castlingRights[p.castlingRights]</pre>
<h1>#8 found 2 clones</h1>
<h2>internal\movegen\perft.go:138</h2>
<pre>                               {
	if p.stopFlag {
		return 0
	}
	if depth > 1 {
		positionPtr.DoMove(move)
		if positionPtr.WasLegalMove() {
			totalNodes += p.miniMax(depth-1, positionPtr, mgListPtr)
		}
		positionPtr.UndoMove()
	} else {
		capture := positionPtr.GetPiece(move.To()) != PieceNone
		enpassant := move.MoveType() == EnPassant
		castling := move.MoveType() == Castling
		promotion := move.MoveType() == Promotion
		positionPtr.DoMove(move)
		if positionPtr.WasLegalMove() {
			totalNodes++
			if enpassant {
				p.EnpassantCounter++
				p.CaptureCounter++
			}
			if capture {
				p.CaptureCounter++
			}
			if castling {
				p.CastleCounter++
			}
			if promotion {
				p.PromotionCounter++
			}
			if positionPtr.HasCheck() {
				p.CheckCounter++
			}
			if !movegens[0].HasLegalMove(positionPtr) {
				p.CheckMateCounter++
			}
		}
		positionPtr.UndoMove()
	}
}</pre>
<h2>internal\movegen\perft.go:187</h2>
<pre>                                                                                                              {
	if p.stopFlag {
		return 0
	}
	if depth > 1 {
		positionPtr.DoMove(move)
		if positionPtr.WasLegalMove() {
			totalNodes += p.miniMaxOD(depth-1, positionPtr, mgListPtr)
		}
		positionPtr.UndoMove()
	} else {
		capture := positionPtr.GetPiece(move.To()) != PieceNone
		enpassant := move.MoveType() == EnPassant
		castling := move.MoveType() == Castling
		promotion := move.MoveType() == Promotion
		positionPtr.DoMove(move)
		if positionPtr.WasLegalMove() {
			totalNodes++
			if enpassant {
				p.EnpassantCounter++
				p.CaptureCounter++
			}
			if capture {
				p.CaptureCounter++
			}
			if castling {
				p.CastleCounter++
			}
			if promotion {
				p.PromotionCounter++
			}
			if positionPtr.HasCheck() {
				p.CheckCounter++
			}
			if !movegens[0].HasLegalMove(positionPtr) {
				p.CheckMateCounter++
			}
		}
		positionPtr.UndoMove()
	}
}</pre>
<h1>#9 found 2 clones</h1>
<h2>internal\testsuite\testsuite.go:293</h2>
<pre>func bestMoveTest(s *search.Search, sl *search.Limits, p *position.Position, t *Test) {
	// start search
	s.StartSearch(*p, *sl)
	s.WaitWhileSearching()
	// check and store result
	for _, m := range t.targetMoves {
		if m == s.LastSearchResult().BestMove {
			// success
			log.Infof("TestSet: id = '%s' SUCCESS", t.id)
			t.actual = s.LastSearchResult().BestMove
			t.value = s.LastSearchResult().BestValue
			t.rType = Success
			return
		} else {
			continue
		}
	}
	// Failed
	log.Infof("TestSet: id = '%s' FAILED", t.id)
	t.actual = s.LastSearchResult().BestMove
	t.value = s.LastSearchResult().BestValue
	t.rType = Failed
}</pre>
<h2>internal\testsuite\testsuite.go:317</h2>
<pre>func avoidMoveMateTest(s *search.Search, sl *search.Limits, p *position.Position, t *Test) {
	// start search
	s.StartSearch(*p, *sl)
	s.WaitWhileSearching()
	// check and store result
	for _, m := range t.targetMoves {
		if m == s.LastSearchResult().BestMove {
			// success
			log.Infof("TestSet: id = '%s' FAILED", t.id)
			t.actual = s.LastSearchResult().BestMove
			t.value = s.LastSearchResult().BestValue
			t.rType = Failed
			return
		} else {
			continue
		}
	}
	// Failed
	log.Infof("TestSet: id = '%s' SUCCESS", t.id)
	t.actual = s.LastSearchResult().BestMove
	t.value = s.LastSearchResult().BestValue
	t.rType = Success
}</pre>
<h1>#10 found 2 clones</h1>
<h2>internal\types\bitboard_test.go:611</h2>
<pre>func TestGetMovesDiagUp(t *testing.T) {

	tests := []struct {
		name    string
		square  Square
		blocker Bitboard
		want    Bitboard
	}{
		{"Square e4 empty diag up", SqE4, 0, PopSquare(DiagUpB1, SqE4)},
		{"Square e4 blocker c2 g6", SqE4, sqBb[SqC2] | sqBb[SqG6], sqBb[SqC2] | sqBb[SqD3] | sqBb[SqF5] | sqBb[SqG6]},
		{"Square a2 blocker c4", SqA2, sqBb[SqC4], sqBb[SqB3] | sqBb[SqC4]},
		{"Square e5 blocker DiagUpA1", SqE5, DiagUpA1, sqBb[SqD4] | sqBb[SqF6]},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := GetMovesDiagUp(tt.square, tt.blocker); got != tt.want {
				t.Errorf("Moves bits = %v, want %v", got.StringGrouped(), tt.want.StringGrouped())
			}
		})
	}
}</pre>
<h2>internal\types\bitboard_test.go:633</h2>
<pre>func TestGetMovesDiagDown(t *testing.T) {

	tests := []struct {
		name    string
		square  Square
		blocker Bitboard
		want    Bitboard
	}{
		{"Square e4 empty diag down", SqE4, 0, PopSquare(DiagDownH1, SqE4)},
		{"Square e4 blocker c6 g2", SqE4, sqBb[SqC6] | sqBb[SqG2], sqBb[SqC6] | sqBb[SqD5] | sqBb[SqF3] | sqBb[SqG2]},
		{"Square a5 blocker c3", SqA5, sqBb[SqC3], sqBb[SqB4] | sqBb[SqC3]},
		{"Square e5 blocker DiagDownH1", SqE5, DiagDownH2, sqBb[SqD6] | sqBb[SqF4]},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := GetMovesDiagDown(tt.square, tt.blocker); got != tt.want {
				t.Errorf("Moves bits = %v, want %v", got.StringGrouped(), tt.want.StringGrouped())
			}
		})
	}
}</pre>
<h1>#11 found 2 clones</h1>
<h2>internal\types\bitboard_test.go:133</h2>
<pre>func TestBitboardDiagUp(t *testing.T) {

	if verbose {
		fmt.Println(DiagUpA1.StringBoard())
		fmt.Println(DiagUpB1.StringBoard())
		fmt.Println(DiagUpC1.StringBoard())
		fmt.Println(DiagUpD1.StringBoard())
		fmt.Println(DiagUpE1.StringBoard())
		fmt.Println(DiagUpF1.StringBoard())
		fmt.Println(DiagUpG1.StringBoard())
		fmt.Println(DiagUpH1.StringBoard())
	}
	assert.Equal(t, "10000000.01000000.00100000.00010000."+
		"00001000.00000100.00000010.00000001 (9241421688590303745)", DiagUpA1.StringGrouped())
	assert.Equal(t, "00000010.00000001.00000000.00000000."+
		"00000000.00000000.00000000.00000000 (32832)", DiagUpG1.StringGrouped())

	if verbose {
		fmt.Println(DiagUpA2.StringBoard())
		fmt.Println(DiagUpA3.StringBoard())
		fmt.Println(DiagUpA4.StringBoard())
		fmt.Println(DiagUpA5.StringBoard())
		fmt.Println(DiagUpA6.StringBoard())
		fmt.Println(DiagUpA7.StringBoard())
		fmt.Println(DiagUpA8.StringBoard())
	}
	assert.Equal(t, "00000000.10000000.01000000.00100000."+
		"00010000.00001000.00000100.00000010 (4620710844295151872)", DiagUpA2.StringGrouped())
	assert.Equal(t, "00000000.00000000.00000000.00000000."+
		"00000000.00000000.10000000.01000000 (144396663052566528)", DiagUpA7.StringGrouped())
}</pre>
<h2>internal\types\bitboard_test.go:165</h2>
<pre>func TestBitboardDiagDown(t *testing.T) {

	if verbose {
		fmt.Println(DiagDownH1.StringBoard())
		fmt.Println(DiagDownH2.StringBoard())
		fmt.Println(DiagDownH3.StringBoard())
		fmt.Println(DiagDownH4.StringBoard())
		fmt.Println(DiagDownH5.StringBoard())
		fmt.Println(DiagDownH6.StringBoard())
		fmt.Println(DiagDownH7.StringBoard())
		fmt.Println(DiagDownH8.StringBoard())
	}
	assert.Equal(t, "00000001.00000010.00000100.00001000."+
		"00010000.00100000.01000000.10000000 (72624976668147840)", DiagDownH1.StringGrouped())
	assert.Equal(t, "00000000.00000000.00000000.00000000."+
		"00000000.00000001.00000010.00000100 (2323998145211531264)", DiagDownH6.StringGrouped())

	if verbose {
		fmt.Println(DiagDownG1.StringBoard())
		fmt.Println(DiagDownF1.StringBoard())
		fmt.Println(DiagDownE1.StringBoard())
		fmt.Println(DiagDownD1.StringBoard())
		fmt.Println(DiagDownC1.StringBoard())
		fmt.Println(DiagDownB1.StringBoard())
		fmt.Println(DiagDownA1.StringBoard())
	}
	assert.Equal(t, "00000100.00001000.00010000.00100000."+
		"01000000.10000000.00000000.00000000 (1108169199648)", DiagDownF1.StringGrouped())
	assert.Equal(t, "01000000.10000000.00000000.00000000."+
		"00000000.00000000.00000000.00000000 (258)", DiagDownB1.StringGrouped())

}</pre>
<h1>#12 found 2 clones</h1>
<h2>internal\moveslice\moveslice_test.go:108</h2>
<pre>func TestMoveArrayPopBack(t *testing.T) {
	ma := NewMoveSlice(MaxMoves)
	assert.Panics(t, func(){ ma.PopBack() })

	ma.PushBack(e2e4)
	ma.PushBack(d7d5)
	ma.PushBack(e4d5)
	ma.PushBack(d8d5)
	ma.PushBack(b1c3)

	// logTest.Debugf("Len=%d", len(*ma))
	// logTest.Debugf("Cap=%d", cap(*ma))
	assert.Equal(t, 5, len(*ma))
	assert.Equal(t, MaxMoves, cap(*ma))

	m1 := ma.PopBack()
	assert.Equal(t, b1c3, m1)
	m2 := ma.PopBack()
	assert.Equal(t, d8d5, m2)
	assert.Equal(t, 3, len(*ma))

	// for i, v := range *ma {
	// 	fmt.Println(i, v)
	// }
}</pre>
<h2>internal\moveslice\moveslice_test.go:153</h2>
<pre>func TestMoveArrayPopFront(t *testing.T) {
	ma := NewMoveSlice(MaxMoves)
	assert.Panics(t, func(){ ma.PopFront() })
	ma.PushFront(e2e4)
	ma.PushFront(d7d5)
	ma.PushFront(e4d5)
	ma.PushFront(d8d5)
	ma.PushFront(b1c3)
	// logTest.Debugf("Len=%d", len(*ma))
	// logTest.Debugf("Cap=%d", cap(*ma))
	assert.Equal(t, 5, len(*ma))
	assert.Equal(t, MaxMoves, cap(*ma))

	m1 := ma.PopFront()
	assert.Equal(t, b1c3, m1)
	m2 := ma.PopFront()
	assert.Equal(t, d8d5, m2)
	assert.Equal(t, 3, len(*ma))

	// for i, v := range *ma {
	// 	fmt.Println(i, v)
	// }
}</pre>
<h1>#13 found 2 clones</h1>
<h2>internal\types\posValues.go:160</h2>
<pre>knightMidGame = [SqLength]Value {
-50,-40,-30,-30,-30,-30,-40,-50,
-40,-20,  0,  0,  0,  0,-20,-40,
-30,  0, 10, 15, 15, 10,  0,-30,
-30,  5, 15, 20, 20, 15,  5,-30,
-30,  0, 15, 20, 20, 15,  0,-30,
-30,  5, 10, 15, 15, 10,  5,-30,
-40,-20,  0,  5,  5,  0,-20,-40,
-50,-25,-20,-30,-30,-20,-25,-50}</pre>
<h2>internal\types\posValues.go:170</h2>
<pre>knightEndGame = [SqLength]Value {
-50,-40,-30,-30,-30,-30,-40,-50,
-40,-20,  0,  0,  0,  0,-20,-40,
-30,  0, 10, 15, 15, 10,  0,-30,
-30,  0, 15, 20, 20, 15,  0,-30,
-30,  0, 15, 20, 20, 15,  0,-30,
-30,  0, 10, 15, 15, 10,  0,-30,
-40,-20,  0,  0,  0,  0,-20,-40,
-50,-40,-20,-30,-30,-20,-40,-50}</pre>
<h1>#14 found 2 clones</h1>
<h2>internal\openingbook\openingbook_test.go:162</h2>
<pre>func TestProcessingSANSmall(t *testing.T) {
	logTest.Info("Starting SAN small test")

	book := NewBook()
	err := book.Initialize(config.Settings.Search.BookPath+"/book_graham.txt", "", San, false, false)
	assert.NoError(t, err, "Initialize book threw error: %s", err)
	assert.Equal(t, 1_256, book.NumberOfEntries())

	// get root entry
	pos := position.NewPosition()
	entry, found := book.GetEntry(pos.ZobristKey())
	assert.True(t, found)
	assert.NotNil(t, entry)
	assert.Equal(t, book.rootEntry, entry.ZobristKey)
	assert.EqualValues(t, entry.ZobristKey, pos.ZobristKey())
	assert.Equal(t, 8, len(entry.Moves))
	assert.Equal(t, 149, entry.Counter)

	pos.DoMove(CreateMove(SqE2, SqE4, Normal, PtNone))
	entry, found = book.GetEntry(pos.ZobristKey())
	assert.True(t, found)
	assert.NotNil(t, entry)
	assert.EqualValues(t, entry.ZobristKey, pos.ZobristKey())
	assert.Equal(t, 8, len(entry.Moves))
	assert.Equal(t, 94, entry.Counter)

	for _, p := range entry.Moves {
		ne, _ := book.GetEntry(position.Key(p.NextEntry))
		out.Printf("%s ==> %#v (%d)\n", Move(p.Move).StringUci(), ne.ZobristKey, ne.Counter)
	}
}</pre>
<h2>internal\openingbook\openingbook_test.go:194</h2>
<pre>func TestProcessingPGNSmall(t *testing.T) {
	logTest.Info("Starting PGN small test")

	book := NewBook()
	err := book.Initialize(config.Settings.Search.BookPath+"/pgn_test.pgn", "", Pgn, false, false)
	assert.NoError(t, err, "Initialize book threw error: %s", err)
	assert.Equal(t, 1_428, book.NumberOfEntries())

	// get root entry
	pos := position.NewPosition()
	entry, found := book.GetEntry(pos.ZobristKey())
	assert.True(t, found)
	assert.NotNil(t, entry)
	assert.Equal(t, book.rootEntry, entry.ZobristKey)
	assert.EqualValues(t, entry.ZobristKey, pos.ZobristKey())
	assert.Equal(t, 2, len(entry.Moves))
	assert.Equal(t, 18, entry.Counter)

	pos.DoMove(CreateMove(SqE2, SqE4, Normal, PtNone))
	entry, found = book.GetEntry(pos.ZobristKey())
	assert.True(t, found)
	assert.NotNil(t, entry)
	assert.EqualValues(t, entry.ZobristKey, pos.ZobristKey())
	assert.Equal(t, 4, len(entry.Moves))
	assert.Equal(t, 12, entry.Counter)

	for _, p := range entry.Moves {
		ne, _ := book.GetEntry(position.Key(p.NextEntry))
		out.Printf("%s ==> %#v (%d)\n", Move(p.Move).StringUci(), ne.ZobristKey, ne.Counter)
	}
}</pre>
<h1>#15 found 2 clones</h1>
<h2>internal\movegen\movegen.go:863</h2>
<pre>                       { // white
	if cr.Has(CastlingWhiteOO) && Intermediate(SqE1, SqH1)&occupiedBB == 0 {
		if assert.DEBUG {
			assert.Assert(position.KingSquare(White) == SqE1, "MoveGen Castling: White King not on e1")
			assert.Assert(position.GetPiece(SqH1) == WhiteRook, "MoveGen Castling: White Rook not on h1")
		}
		ml.PushBack(CreateMoveValue(SqE1, SqG1, Castling, PtNone, Value(-5000)))
	}
	if cr.Has(CastlingWhiteOOO) && Intermediate(SqE1, SqA1)&occupiedBB == 0 {
		if assert.DEBUG {
			assert.Assert(position.KingSquare(White) == SqE1, "MoveGen Castling: White King not on e1")
			assert.Assert(position.GetPiece(SqA1) == WhiteRook, "MoveGen Castling: White Rook not on a1")
		}
		ml.PushBack(CreateMoveValue(SqE1, SqC1, Castling, PtNone, Value(-5000)))
	}
}</pre>
<h2>internal\movegen\movegen.go:878</h2>
<pre>       { // black
	if cr.Has(CastlingBlackOO) && Intermediate(SqE8, SqH8)&occupiedBB == 0 {
		if assert.DEBUG {
			assert.Assert(position.KingSquare(Black) == SqE8, "MoveGen Castling: Black King not on e8")
			assert.Assert(position.GetPiece(SqH8) == BlackRook, "MoveGen Castling: Black Rook not on h8")
		}
		ml.PushBack(CreateMoveValue(SqE8, SqG8, Castling, PtNone, Value(-5000)))
	}
	if cr.Has(CastlingBlackOOO) && Intermediate(SqE8, SqA8)&occupiedBB == 0 {
		if assert.DEBUG {
			assert.Assert(position.KingSquare(Black) == SqE8, "MoveGen Castling: Black King not on e8")
			assert.Assert(position.GetPiece(SqA8) == BlackRook, "MoveGen Castling: Black Rook not on a8")
		}
		ml.PushBack(CreateMoveValue(SqE8, SqC8, Castling, PtNone, Value(-5000)))
	}
}</pre>
<h1>#16 found 2 clones</h1>
<h2>internal\position\position_test.go:591</h2>
<pre>res = (GetPseudoAttacks(Rook, sq)&p.piecesBb[White][Rook] != 0 || (GetPseudoAttacks(Rook, sq)&p.piecesBb[White][Queen] != 0)) &&
	(((GetMovesOnRank(sq, p.OccupiedAll()) |
		GetMovesOnFileRotated(sq, p.occupiedBbL90[White]|p.occupiedBbL90[Black])) &
		(p.piecesBb[White][Rook] | p.piecesBb[White][Queen])) != 0) &&
	(GetPseudoAttacks(Bishop, sq)&p.piecesBb[White][Bishop] != 0 || (GetPseudoAttacks(Bishop, sq)&p.piecesBb[White][Queen] != 0)) &&
	(((GetMovesDiagUpRotated(sq, p.occupiedBbR45[White]|p.occupiedBbR45[Black]) |
		GetMovesDiagDownRotated(sq, p.occupiedBbL45[White]|p.occupiedBbL45[Black])) &
		(p.piecesBb[White][Bishop] | p.piecesBb[White][Queen])) != 0)</pre>
<h2>internal\position\position_test.go:600</h2>
<pre>res = (GetPseudoAttacks(Rook, sq)&p.piecesBb[Black][Rook] != 0 || (GetPseudoAttacks(Rook, sq)&p.piecesBb[Black][Queen] != 0)) &&
	(((GetMovesOnRank(sq, p.OccupiedAll()) |
		GetMovesOnFileRotated(sq, p.occupiedBbL90[Black]|p.occupiedBbL90[Black])) &
		(p.piecesBb[Black][Rook] | p.piecesBb[Black][Queen])) != 0) &&
	(GetPseudoAttacks(Bishop, sq)&p.piecesBb[Black][Bishop] != 0 || (GetPseudoAttacks(Bishop, sq)&p.piecesBb[Black][Queen] != 0)) &&
	(((GetMovesDiagUpRotated(sq, p.occupiedBbR45[Black]|p.occupiedBbR45[Black]) |
		GetMovesDiagDownRotated(sq, p.occupiedBbL45[Black]|p.occupiedBbL45[Black])) &
		(p.piecesBb[Black][Bishop] | p.piecesBb[Black][Queen])) != 0)</pre>
